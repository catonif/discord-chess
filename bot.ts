/* code generated by tsc, og file in the same dir: bot.ts */

import { Message } from "discord.js";

require('dotenv').config();

const Discord = require('discord.js');
const client = new Discord.Client();

const enum ChsType {
	Pedone = 'p', Re = 'k', Regina = 'q', Torre = 't', Cavallo = 'c', Alfiere = 'a'
}

class ChsPiece {

	public type: ChsType;
	public team: boolean;

	constructor(type: ChsType, team: boolean) {
		this.type = type;
		this.team = team;
	}

	public static fromChar(c: string, t: boolean) : ChsPiece {
		let r: ChsPiece;
		r.team = t;
		r.type = <ChsType>c;
		return r;
	}

	public getCrdFromRule(message: string) : Coord {
		try {
			switch (this.type) {
	
				case ChsType.Pedone:
					if (message.length != 1) lengthThrow("1");
					const crds: Coord = getYXFromNumpad(parseThrow(message, 0));
					crds.x = Math.abs(crds.x) * (this.team ? 1 : -1);
					return crds;
	
				case ChsType.Re: 
					if (message.length != 1) lengthThrow("1");
					return getYXFromNumpad(parseThrow(message, 0));
	
				case ChsType.Regina: 
					fastPieceLength(message);
					return getYXFromNumpad(parseThrow(message, 0)).multiply(parseThrow(message, 1));
				case ChsType.Alfiere: 
					fastPieceLength(message);
					return getYXNumpadDiag(parseThrow(message, 0)).multiply(parseThrow(message, 1));
				case ChsType.Torre:
					fastPieceLength(message);
					return getYXNumpadPerp(parseThrow(message, 0)).multiply(parseThrow(message, 1));
	
				case ChsType.Cavallo: 
					return getYXNumpadHorse(parseInt(message));
				
			}
		} catch (e) { throw pieceName(this.type) + e; }
	}

}

class Coord {

	public x: number;
	public y: number;

	constructor (x: number, y: number) {
		this.x = x;
		this.y = y;
	}

	public toPrint() : string {
		return "[x:" + this.x + "; y:" + this.y + "]";
	}

	public multiply(m: number) : Coord {
		return new Coord(this.x * m, this.y * m);
	}

	public add(c: Coord) : Coord {
		return new Coord(this.x + c.x, this.y + c.y);
	}

	public inBoard() : boolean {
		return (this.x >= 0 && this.y >= 0 && this.x < 8 || this.y < 8);
	}

}

let currentUsers: string[] = [];

let currentPieces: ChsPiece[][] = []

function setAtCoord(crd: Coord, p: ChsPiece) : void {
	try {
		currentPieces[crd.y][crd.x] = p;
	} catch {
		console.log("Crashed trying to get position at " + crd.toPrint());
		return null;
	}
}

function getAtCoord(crd: Coord) : ChsPiece {

	try {
		return currentPieces[crd.y][crd.x];
	} catch {
		console.log("Crashed trying to get position at " + crd.toPrint());
		return null;
	}

}

function nullifyPieces() : void {
	currentPieces = new Array<Array<ChsPiece>>(8);
	for (let y: number = 0; y < 8; y++) {
		currentPieces[y] = new Array<ChsPiece>(8);
		for (let x = 0; x < 8; x++) {
			currentPieces[y][x] = null;
		}
	}
}

function stdPieces() : void {

	nullifyPieces();

	for (let x: number = 1; x < 7; x += 5) {
		for (let y: number = 0; y < 8; y++) {
			currentPieces[y][x] = new ChsPiece(ChsType.Pedone, x < 2);
			let pieceType: ChsType;
			switch (y) {
				case 0: case 7: pieceType = ChsType.Torre;
				break; case 1: case 6: pieceType = ChsType.Cavallo;
				break; case 2: case 5: pieceType = ChsType.Alfiere;
				break; case 3: pieceType = ChsType.Regina;
				break; case 4: pieceType = ChsType.Re;
			} currentPieces[y][x + (x < 2 ? -1 : 1)] = new ChsPiece(pieceType, x < 2);
		}
	}
}

function emojiID(str: string) : string {
	switch (str) {
		case   'b': return '768206330321305601';
		case 'bba': return '768205826468216922';
		case 'bbc': return '768205826438725632';
		case 'bbk': return '768205826065825864';
		case 'bbp': return '768205826364014604';
		case 'bbq': return '768205826413690880';
		case 'bbt': return '768205826325610497';
		case 'bwa': return '768205826120744983';
		case 'bwc': return '768205826133065790';
		case 'bwk': return '768205826560360468';
		case 'bwp': return '768205826581725194';
		case 'bwq': return '768205826632187924';
		case 'bwt': return '768205826585919488';
		case   'w': return '768206330430881842';
		case 'wba': return '768205826623537212';
		case 'wbc': return '768205826136473671';
		case 'wbk': return '768205826481324033';
		case 'wbp': return '768205826145517619';
		case 'wbq': return '768205826070282292';
		case 'wbt': return '768205826410020945';
		case 'wwa': return '768205826552496158';
		case 'wwc': return '768205826539651072';
		case 'wwk': return '768205826338717717';
		case 'wwp': return '768205826174222357';
		case 'wwq': return '768205826245525525';
		case 'wwt': return '768205826258763797';
	}
}

function emoji(str: string) : string {
	return '<:chess_' + str + ':' + emojiID(str) + '>';
}

const emojiNumber: string[] = [ ':zero:', ':one:', ':two:', ':three:', ':four:', ':five:', ':six:', ':seven:', ':eight:', ':nine:', ];

let lastRender: any = null;
let lastRenderMessage: any = null;

function renderPieces(msg: any, isPoint: boolean) : void {
	let text: string = '';
	let bgc: boolean = true; /// black:white
	text += ':black_large_square:'; for (let i: number = 0; i < 8; i++) text += emojiNumber[i]; /// y axis
	for (let y: number = 0; y < 8; y++) {
		text += '\n' + emojiNumber[y];
		for (let x: number = 0; x < 8; x++) {
			bgc = !bgc;
			let currentPieceStr: string = bgc ? 'b' : 'w';
			if (currentPieces[y] != null) {
				if (currentPieces[y][x] != null) {
					currentPieceStr += (currentPieces[y][x].team ? 'b' : 'w') + currentPieces[y][x].type;
				}
			} text += emoji(currentPieceStr);
		} bgc = !bgc;
	}
	if ((lastRenderMessage == null) || isPoint) {
		lastRender = getEmbed("Current game state", text);
		msg.channel.send(lastRender).then((sent: any) => lastRenderMessage = sent);
	} else {
		lastRender.setDescription(text);
		lastRenderMessage.edit(lastRender);
	}
	
}

function parseThrow(fullMessage: string, index: number) : number {
	const r: number = parseInt(fullMessage.charAt(index));
	if (isNaN(r)) throw "[" + index + "] should be number";
	return r;
}

function lengthThrow(length: string) : void {
	throw "invalid message length: " + length + " digits expected";
}

function fastPieceLength(fullMessage: string) : string {
	if (fullMessage.length != 2) {
		if (fullMessage.length == 1) return fullMessage + "1"; else lengthThrow("2 or 1");
	} return fullMessage;
}



function getYXNumpadHorse(i: number) : Coord {
	const bMove: number = i % 10;
	const aMove: number = (i - bMove) / 10;
	let aDir: Coord;
	let bDir: Coord;
	try { aDir = getYXNumpadPerp(aMove); } catch (e) { throw "[0]: " + e; }
	try { bDir = getYXNumpadDiag(bMove); } catch (e) { throw "[1]: " + e; }
	if ((aDir.x == 0) && (aDir.y != bDir.y)) throw "digits are not near in the numpad";
	else if ((aDir.y == 0) && (aDir.x != bDir.x)) throw "digits are not near in the numpad";
	return aDir.add(bDir);
}

function getYXFromNumpad(i: number) : Coord {
	try { return getYXNumpadDiag(i); }
	catch {
		try { return getYXNumpadPerp(i); }
		catch { throw "invalid numpad dir"; }
	}
}

function getYXNumpadPerp(i: number) : Coord {
	switch (i) {
		case 8: return new Coord( 0,-1);
		case 4: return new Coord(-1, 0);
		case 6: return new Coord( 1, 0);
		case 2: return new Coord( 0, 1);
		default: throw "invalid perp dir";
	}
}

function getYXNumpadDiag(i: number) : Coord {
	switch (i) {
		case 7: return new Coord(-1,-1); case 9: return new Coord(1,-1);
		case 1: return new Coord(-1, 1); case 3: return new Coord(1, 1);
		default: throw "invalid diag dir";
	}
}

let gaming: boolean = false;

let gamersPositions: Coord[] = [];

let latestMsg: any = null;

function gameStop(msg: any) : void {
	if (!gaming) {
		msg.reply('There are no games currently');
		return;
	} gaming = false;
	nullifyPieces();
	gamersPositions = [];
	msg.reply('The game is over and the board emptied');
}

function getIndexFromTeam(t: boolean, index: number) : Coord {
	for (let i = 0; i < 16; i++) {
		let piecePos: Coord = getCrdFromIndex(i, t);
		if (getAtCoord(piecePos) != null) index--;
		if (index < 0) {
			return piecePos;
		}
	}
	return null;
}

function gameStart(msg: any) : void {
	let outputText: string = '';
	try {
		if (gaming) {
			msg.reply("There's already a game currently\n");
			return;
		} gaming = true;
		let teamCount: number[] = [Math.ceil(currentUsers.length / 2), Math.floor(currentUsers.length/ 2)];
		outputText += 'Team black: ' + teamCount[0] + '; Team white: ' + teamCount[1] + '\n';
		stdPieces();
		let die: number = 0;
		for (let t: number = 0; t < 2; t++) {
			if (teamCount[t] == 0) {
				for (let i: number = 0; i < 16; i++) {
					setAtCoord(getCrdFromIndex(i, t != 0), null);
				}
			} else {
				for (let i: number = 0; i < (16 - teamCount[t]); i++) {
					let randIndex: number = Math.floor(Math.random() * 16);
					let pos: Coord = getCrdFromIndex(randIndex, t != 0);
					if (getAtCoord(pos) == null) i--;
					setAtCoord(pos, null);
					die++;
					if (die > 256) break;
				}
			}
		} outputText += 'I placed the pieces.\n';
		//let dbgText: string = 'startingDebug\n';
		try {
			let userIndex: number = 0;
			for (let t: number = 0; t < 2; t++) {
				if (teamCount[t] == 0) {
					outputText += "There's no one in the " + (t == 0 ? 'black' : 'white') + " team\n";
					//dbgText += 'skipping team ' + t + ' cuz 0body is in it\n';
					continue;
				}
				for (let i = 0; i < teamCount[t]; i++) {
					//dbgText += 'index is '+i+'/'+teamCount[t]+' and team is '+t+'\n';
					let superPos: Coord = getIndexFromTeam(t != 0, i);
					//dbgText += 'superPos is ' + stringCrd(superPos) + '\n';
					gamersPositions.push(superPos);
					let superPiece: ChsPiece = getAtCoord(superPos);
					outputText += currentUsers[userIndex] + ' is a ' + (t == 0 ? 'black ' : 'white ') + pieceName(superPiece.type) + ' at ' + superPos.toPrint() + '\n';
					userIndex++;
				}
			}
		} catch (e) {
			//sendEmbed(msg, 'i crashed but i was debugging, hehe', e.message+'\n'+dbgText); 
		}
		msg.channel.send(outputText + 'Game started with ' + currentUsers.length + ' users. Type `.users` to see who');
	} catch (e) { sendEmbed(msg, 'Whoops, I crashed', e.message); }
	renderPieces(msg, true);
}

function getCrdFromIndex(i: number, t: boolean) {
	return new Coord(Math.floor(i / 8) + (t ? 6 : 0), i % 8);
}

client.on('ready', () => {
	console.log('Logged in as ' + client.user.tag);
	nullifyPieces();
});

client.on('message', msg => {
	if (msg.author.bot) return;
	command(msg);
	latestMsg = msg;
});

function pieceName(p: ChsType) : string {
	switch (p) {
		case ChsType.Pedone: return 'pawn';
		case ChsType.Regina: return 'queen';
		case ChsType.Re: return 'king';
		case ChsType.Alfiere: return 'bishop';
		case ChsType.Cavallo: return 'knight';
		case ChsType.Torre: return 'rook';
	}
}

function sendEmbed(msg: any, title: string, text: string) : any {
	let emb: any = new Discord.MessageEmbed()
		.setTitle(title)
		.setColor(0xffffff)
		.setDescription(text);
	msg.channel.send(emb);
	return emb;
}

function getEmbed(title: string, text: string) : any {
	let emb: any = new Discord.MessageEmbed()
		.setTitle(title)
		.setColor(0xffffff)
		.setDescription(text);
	return emb;
}

function genericHelp(msg: any, parameters: string[]) : void {
	if (parameters.length == 1) {
		sendEmbed(msg, 'Generic help',
			'`.` renders the scene\n' + 
			'`.join` or `.j` will make you join the game\n' + 
			'`.quit` or `.q` will kick you out from the current game players\n' +
			'`.users` or `.u` lists all the users that are currently playing\n' +
			'`.start` or `.s` will create a chess board with as many pieces as current players\n' +
			'`.stop` will clear the board and stop the current game\n' +
			'`.empty` clears the board\n' +
			'`.help ita` explains all the italian terms used\n' +
			'`.help debug` shows debug commands\n' +
			'`.help <first (italian) letter of a piece>` to get info and rules about it\n' +
			'`<param>` means mandatory parameter\n`[param]` means optional parameters');
	} else if (parameters.length == 2) {
		switch (parameters[1]) {
			case 'debug':
				sendEmbed(msg, 'Debug help',
					'`.set <X> <Y> <piece type> <team>` to create a piece on the board\n' +
					'`.set <X> <Y> empty` to clear a tile on the board\n' +
					'`.index <piece index> <team>` gets the tile position from index and team of standard chess\n' +
					'`.index all <team>` lists all the indices of a team\n' +
					'`.iset <piece index> <team> [<piece type> <team>] | [empty]` like .set but from .index\n' +
					'`.umove <X of piece pos> <Y of piece pos> <X of future pos> <Y of future pos>` to move piece without rules\n' +
					//'`.move <X of piece pos> <Y of piece pos> <moving message>` to move piece following game rules\n' +
					'`.reset` sets the board to standard chess\n' +
					'`.ping` pong!\n' +
					'`.emoji <emoji name>` sends an emoji from this server from name');
			break; case 'ita':
				sendEmbed(msg, 'Italian terms used',
					"I did'n want to get confused, so i'll confuse you instead.\n" +
					'pawn (q) = pawn\nknight (c) = knight\nbishop (a) = bishop\nrook (t) = rook\nqueen (q) = queen\nre (k) = king');
			break; case 'pawn': case 'p':
				sendEmbed(msg, 'pawn movement ' + emoji('wbp'),
					"The pawn's moving message sintax is `<direction>`\n" +
					"The direction can be `8` (up) or `2` (down)\n" +
					"`4` and `6` will both go rigth if the piece is black, left if the piece is white\n"+
					"The same horizontal direction is applied to `7`, `9`, `1` and `3`");
			break; case 'rook': case 't':
				sendEmbed(msg, 'rook movement ' + emoji('wbt'),
					"The rook's moving message sintax is `<direction>[how many times]`\n" +
					"The direction can be `8`, `2`, `4` and `6`. This move will be played the times that the second parameters says, a number from 0 to 9");
			break; case 'queen': case 'q':
				sendEmbed(msg, 'queen movement ' + emoji('wbq'),
					"The queen's moving message sintax is `<direction>[how many times]`\n" +
					"The direction can be every number from `1` to `9` except `5`. This move will be played the times that the second parameters says, a number from 0 to 9");
			break; case 'king': case 'k':
				sendEmbed(msg, 'king movement ' + emoji('wbk'),
					"The king's moving message sintax is `<direction>`\n" +
					"The direction can be `8`, `2`, `4` and `6`.");
			break; case 'bishop': case 'a':
				sendEmbed(msg, 'bishop movement ' + emoji('wba'),
					"The bishop's moving message sintax is `<direction>[how many times]`\n" +
					"The direction can be `7`, `9`, `1` and `3`. This move will be played the times that the second parameters says, a number from 0 to 9");
			break; case 'knight': case 'c':
				sendEmbed(msg, 'knight movement ' + emoji('wbc'),
					"The knight's moving message sintax is `<first direction><second direction>`\n" +
					"The first direction can be `8`, `2`, `4` and `6`.\n" +
					"The second one needs to be one of the two diagonal keys next to it\n"+
					"eg: `23` = L; `87` = ꓶ; `21` = ⅃; `27` = invalid move");
			break; case 'me': msg.reply('no');
			break;
		}
	}
}

function command(msg: any) {
	const args: string[] = msg.content.split(' ');
	if ((currentUsers.includes(msg.author.tag)) && (args[0].charAt(0) !== '.') && gaming) {
		try {
			let gamerIndex: number = currentUsers.findIndex(item => item === msg.author.tag);
			let startPos: Coord = gamersPositions[gamerIndex];
			try {
				
				let futurePos: Coord = startPos.add(getAtCoord(startPos).getCrdFromRule(args[0]));
				if (!startPos.inBoard()) {
					msg.reply('stay in the board!');
					return;
				}

				let killed: ChsPiece = getAtCoord(futurePos);
				if (killed != null) {
					for (let dedIndex: number = 0; dedIndex < gamersPositions.length; dedIndex++) {
						if (gamersPositions[dedIndex].x == futurePos.x && gamersPositions[dedIndex].y == futurePos.y) {
							let killedGamerIndex = gamersPositions.findIndex(a => a.x == futurePos.x && a.y == futurePos.y);
							msg.reply("You killed " + currentUsers[killedGamerIndex]);
							currentUsers.splice(killedGamerIndex, 1);
						}
					}
				}

				setAtCoord(futurePos, getAtCoord(startPos));
				setAtCoord(startPos, null);
				
				gamersPositions[gamerIndex] = futurePos;
				renderPieces(msg, false);
				try { msg.delete(); } catch {}
			} catch (e) { msg.reply(e); }
		} catch (e) {
			sendEmbed(msg, 'Invalid move! js crash', e.message);
		}
		return;
	}

	switch (args[0]) {
		
		/// debug
		case '.ping': msg.reply('pong!');
		break; case '.emoji': msg.reply(emoji(args[1]));
		break; case '.index':
			let index = parseInt(args[1]);
			let iTeam = !!parseInt(args[2]);
			if (args[1] == 'all') {
				let text = '';
				for (let i = 0; i < 16; i++) {
					text += i + ' is ' + getCrdFromIndex(i, iTeam).toPrint() + '\n';
				} sendEmbed(msg, 'All the indices of ' + (iTeam ? 'white' : 'black') + ' team', text);
			} else {
				msg.reply('Index ' + index + ' of team ' + (iTeam ? 'white' : 'black') + ' is ' + getCrdFromIndex(index, iTeam).toPrint());
			}
		break; case '.help': genericHelp(msg, args);
		break; case '.echo': {
			latestMsg.channel.send(msg.content.slice(6,msg.content.length));
			try { msg.delete(); } catch {}
		}
		break; case '.del': try { msg.delete(); } catch {}
		
		/// users playing
		break; case '.j': case '.join':
			if (!currentUsers.includes(msg.author.tag)) {
				currentUsers.push(msg.author.tag);
				msg.channel.send('<@' + msg.author.id + '> joined the game');
			} else msg.reply('You already joined');
			
		break; case '.i':
			const userName = msg.content.substring(3);
			if (!currentUsers.includes(userName)) {
				currentUsers.push(userName);
				msg.channel.send(userName+' joined the game');
			} else msg.reply(userName+' already joined');
			
		break; case '.q': case '.quit':
			if (currentUsers.includes(msg.author.tag)) {
				currentUsers.splice(currentUsers.findIndex(tag => tag === msg.author.tag), 1);
				msg.channel.send('<@' + msg.author.id + '> left the game');
			} else msg.reply('You didn\'t join');
			
		break; case '.k':
			const userNameKick: string = msg.content.substring(3);
			if (currentUsers.includes(userNameKick)) {
				currentUsers.splice(currentUsers.findIndex(tag => tag === userNameKick), 1);
				msg.channel.send(userNameKick + ' was kicked out by ' + msg.author.tag);
			} else msg.reply(userNameKick + " didn't join");
			
		break; case '.u': case '.users':
			let text: string = '';
			if (currentUsers.length == 0) text = 'No users joined :(';
			else {
				for (let i: number = 0; i < currentUsers.length; i++) {
					text += (i + 1).toString() + '. ' + currentUsers[i] + (gaming ? (': ' + gamersPositions[i].toPrint()) : '') + '\n';
				}
			} sendEmbed(msg, 'Current users', text);
		
		break; case '.': renderPieces(msg, true);
		
		break; case '.empty': nullifyPieces();
		
		break; case '.set': /// arg1:startX; arg2:startY; arg3:empty; | [arg3:type; arg4:team]
			const piecePos: Coord = new Coord(parseInt(args[1]), parseInt(args[2]));
			if (args[3] === 'empty') {
				setAtCoord(piecePos, null);
				msg.channel.send('Piece at ' + piecePos.toPrint() + ' succesfully emptied');
			} else {
				const team = !!parseInt(args[4]);
				setAtCoord(piecePos, ChsPiece.fromChar(args[3], team));
				msg.reply('Piece at ' + piecePos.toPrint() + ' succesfully set to ' + (team ? 'black' : 'white') + pieceName(<ChsType>args[3]));
			}
			
		break; case '.iset':
			const iPiecePos: Coord = getCrdFromIndex(parseInt(args[1]), !!parseInt(args[2]));
			if (args[3] === 'empty') {
				setAtCoord(iPiecePos, null);
				msg.channel.send('Piece at ' + iPiecePos.toPrint() + ' succesfully emptied');
			} else {
				const team = !!parseInt(args[4]);
				setAtCoord(iPiecePos, ChsPiece.fromChar(args[3], team));
				msg.reply('Piece at ' + iPiecePos.toPrint() + ' succesfully set to ' + (team ? 'black' : 'white') + pieceName(<ChsType>args[3]));
			}
			
		break; case '.reset': stdPieces(); msg.reply('Pieces succesfuly resetted to standard chess');
		
		break; case '.umove':
			const startPos: Coord = new Coord(parseInt(args[1]), parseInt(args[2]));
			const targetPos: Coord = new Coord(parseInt(args[3]), parseInt(args[4]));
			const startValue: ChsPiece = getAtCoord(startPos);
			if (startValue == null) {
				msg.reply("Can't move empty tile");
			} else {
				setAtCoord(targetPos, startValue);
				setAtCoord(startPos, null);
				msg.reply((startValue.team ? 'Black' : 'White') + ' ' + pieceName(startValue.type) + ' at ' + startPos.toPrint() + ' succesfully moved to ' + targetPos.toPrint() + ' without following any game rules');
			}
			
		break; case '.version':
			if (args.length < 2) msg.reply('current version: v1');
			else {
				if (args[1] == "1") msg.reply('v1: first release');
				else msg.reply('there has never been a ' + args[1] + 'version');
			}
			
		break; case '.info':
			sendEmbed(msg, 'Discord 32Chess',
				'Author: catonif#4146\n' +
				'Version: v1 (`.version <version-name>` for more info)\n' +
				'Source code: https://github.com/catonif/discord-chess/ \n' +
				'Type `.help` to learn commands.');
			break;
		
			
		break; case '.start': case '.s':
			gameStart(msg);
		
		break; case '.stop': gameStop(msg);
		
		// one lonely beak ):
		break;
	}
}

client.login(process.env.DISCORDJS_BOT_TOKEN);
