"use strict";
/* code generated by tsc, og file in the same dir: bot.ts */
exports.__esModule = true;
require('dotenv').config();
var Discord = require('discord.js');
var client = new Discord.Client();
var ChsPiece = /** @class */ (function () {
    function ChsPiece(type, team) {
        this.type = type;
        this.team = team;
    }
    ChsPiece.fromChar = function (c, t) {
        var r;
        r.team = t;
        r.type = c;
        return r;
    };
    ChsPiece.prototype.getCrdFromRule = function (message) {
        try {
            switch (this.type) {
                case "p" /* Pedone */:
                    if (message.length != 1)
                        lengthThrow("1");
                    var crds = getYXFromNumpad(parseThrow(message, 0));
                    crds.x = Math.abs(crds.x) * (this.team ? 1 : -1);
                    return crds;
                case "k" /* Re */:
                    if (message.length != 1)
                        lengthThrow("1");
                    return getYXFromNumpad(parseThrow(message, 0));
                case "q" /* Regina */:
                    fastPieceLength(message);
                    return getYXFromNumpad(parseThrow(message, 0)).multiply(parseThrow(message, 1));
                case "a" /* Alfiere */:
                    fastPieceLength(message);
                    return getYXNumpadDiag(parseThrow(message, 0)).multiply(parseThrow(message, 1));
                case "t" /* Torre */:
                    fastPieceLength(message);
                    return getYXNumpadPerp(parseThrow(message, 0)).multiply(parseThrow(message, 1));
                case "c" /* Cavallo */:
                    return getYXNumpadHorse(parseInt(message));
            }
        }
        catch (e) {
            throw pieceName(this.type) + e;
        }
    };
    return ChsPiece;
}());
var Coord = /** @class */ (function () {
    function Coord(x, y) {
        this.x = x;
        this.y = y;
    }
    Coord.prototype.toPrint = function () {
        return "[x:" + this.x + "; y:" + this.y + "]";
    };
    Coord.prototype.multiply = function (m) {
        return new Coord(this.x * m, this.y * m);
    };
    Coord.prototype.add = function (c) {
        return new Coord(this.x + c.x, this.y + c.y);
    };
    Coord.prototype.inBoard = function () {
        return (this.x >= 0 && this.y >= 0 && this.x < 8 || this.y < 8);
    };
    return Coord;
}());
var currentUsers = [];
var currentPieces = [];
function setAtCoord(crd, p) {
    try {
        currentPieces[crd.y][crd.x] = p;
    }
    catch (_a) {
        console.log("Crashed trying to get position at " + crd.toPrint());
        return null;
    }
}
function getAtCoord(crd) {
    try {
        return currentPieces[crd.y][crd.x];
    }
    catch (_a) {
        console.log("Crashed trying to get position at " + crd.toPrint());
        return null;
    }
}
function nullifyPieces() {
    currentPieces = new Array(8);
    for (var y = 0; y < 8; y++) {
        currentPieces[y] = new Array(8);
        for (var x = 0; x < 8; x++) {
            currentPieces[y][x] = null;
        }
    }
}
function stdPieces() {
    nullifyPieces();
    for (var x = 1; x < 7; x += 5) {
        for (var y = 0; y < 8; y++) {
            currentPieces[y][x] = new ChsPiece("p" /* Pedone */, x < 2);
            var pieceType = void 0;
            switch (y) {
                case 0:
                case 7:
                    pieceType = "t" /* Torre */;
                    break;
                case 1:
                case 6:
                    pieceType = "c" /* Cavallo */;
                    break;
                case 2:
                case 5:
                    pieceType = "a" /* Alfiere */;
                    break;
                case 3:
                    pieceType = "q" /* Regina */;
                    break;
                case 4: pieceType = "k" /* Re */;
            }
            currentPieces[y][x + (x < 2 ? -1 : 1)] = new ChsPiece(pieceType, x < 2);
        }
    }
}
function emojiID(str) {
    switch (str) {
        case 'b': return '768206330321305601';
        case 'bba': return '768205826468216922';
        case 'bbc': return '768205826438725632';
        case 'bbk': return '768205826065825864';
        case 'bbp': return '768205826364014604';
        case 'bbq': return '768205826413690880';
        case 'bbt': return '768205826325610497';
        case 'bwa': return '768205826120744983';
        case 'bwc': return '768205826133065790';
        case 'bwk': return '768205826560360468';
        case 'bwp': return '768205826581725194';
        case 'bwq': return '768205826632187924';
        case 'bwt': return '768205826585919488';
        case 'w': return '768206330430881842';
        case 'wba': return '768205826623537212';
        case 'wbc': return '768205826136473671';
        case 'wbk': return '768205826481324033';
        case 'wbp': return '768205826145517619';
        case 'wbq': return '768205826070282292';
        case 'wbt': return '768205826410020945';
        case 'wwa': return '768205826552496158';
        case 'wwc': return '768205826539651072';
        case 'wwk': return '768205826338717717';
        case 'wwp': return '768205826174222357';
        case 'wwq': return '768205826245525525';
        case 'wwt': return '768205826258763797';
    }
}
function emoji(str) {
    return '<:chess_' + str + ':' + emojiID(str) + '>';
}
var emojiNumber = [':zero:', ':one:', ':two:', ':three:', ':four:', ':five:', ':six:', ':seven:', ':eight:', ':nine:',];
var lastRender = null;
var lastRenderMessage = null;
function renderPieces(msg, isPoint) {
    var text = '';
    var bgc = true; /// black:white
    text += ':black_large_square:';
    for (var i = 0; i < 8; i++)
        text += emojiNumber[i]; /// y axis
    for (var y = 0; y < 8; y++) {
        text += '\n' + emojiNumber[y];
        for (var x = 0; x < 8; x++) {
            bgc = !bgc;
            var currentPieceStr = bgc ? 'b' : 'w';
            if (currentPieces[y] != null) {
                if (currentPieces[y][x] != null) {
                    currentPieceStr += (currentPieces[y][x].team ? 'b' : 'w') + currentPieces[y][x].type;
                }
            }
            text += emoji(currentPieceStr);
        }
        bgc = !bgc;
    }
    if ((lastRenderMessage == null) || isPoint) {
        lastRender = getEmbed("Current game state", text);
        msg.channel.send(lastRender).then(function (sent) { return lastRenderMessage = sent; });
    }
    else {
        lastRender.setDescription(text);
        lastRenderMessage.edit(lastRender);
    }
}
function parseThrow(fullMessage, index) {
    var r = parseInt(fullMessage.charAt(index));
    if (isNaN(r))
        throw "[" + index + "] should be number";
    return r;
}
function lengthThrow(length) {
    throw "invalid message length: " + length + " digits expected";
}
function fastPieceLength(fullMessage) {
    if (fullMessage.length != 2) {
        if (fullMessage.length == 1)
            return fullMessage + "1";
        else
            lengthThrow("2 or 1");
    }
    return fullMessage;
}
function getYXNumpadHorse(i) {
    var bMove = i % 10;
    var aMove = (i - bMove) / 10;
    var aDir;
    var bDir;
    try {
        aDir = getYXNumpadPerp(aMove);
    }
    catch (e) {
        throw "[0]: " + e;
    }
    try {
        bDir = getYXNumpadDiag(bMove);
    }
    catch (e) {
        throw "[1]: " + e;
    }
    if ((aDir.x == 0) && (aDir.y != bDir.y))
        throw "digits are not near in the numpad";
    else if ((aDir.y == 0) && (aDir.x != bDir.x))
        throw "digits are not near in the numpad";
    return aDir.add(bDir);
}
function getYXFromNumpad(i) {
    try {
        return getYXNumpadDiag(i);
    }
    catch (_a) {
        try {
            return getYXNumpadPerp(i);
        }
        catch (_b) {
            throw "invalid numpad dir";
        }
    }
}
function getYXNumpadPerp(i) {
    switch (i) {
        case 8: return new Coord(0, -1);
        case 4: return new Coord(-1, 0);
        case 6: return new Coord(1, 0);
        case 2: return new Coord(0, 1);
        default: throw "invalid perp dir";
    }
}
function getYXNumpadDiag(i) {
    switch (i) {
        case 7: return new Coord(-1, -1);
        case 9: return new Coord(1, -1);
        case 1: return new Coord(-1, 1);
        case 3: return new Coord(1, 1);
        default: throw "invalid diag dir";
    }
}
var gaming = false;
var gamersPositions = [];
var latestMsg = null;
function gameStop(msg) {
    if (!gaming) {
        msg.reply('There are no games currently');
        return;
    }
    gaming = false;
    nullifyPieces();
    gamersPositions = [];
    msg.reply('The game is over and the board emptied');
}
function getIndexFromTeam(t, index) {
    for (var i = 0; i < 16; i++) {
        var piecePos = getCrdFromIndex(i, t);
        if (getAtCoord(piecePos) != null)
            index--;
        if (index < 0) {
            return piecePos;
        }
    }
    return null;
}
function gameStart(msg) {
    var outputText = '';
    try {
        if (gaming) {
            msg.reply("There's already a game currently\n");
            return;
        }
        gaming = true;
        var teamCount = [Math.ceil(currentUsers.length / 2), Math.floor(currentUsers.length / 2)];
        outputText += 'Team black: ' + teamCount[0] + '; Team white: ' + teamCount[1] + '\n';
        stdPieces();
        var die = 0;
        for (var t = 0; t < 2; t++) {
            if (teamCount[t] == 0) {
                for (var i = 0; i < 16; i++) {
                    setAtCoord(getCrdFromIndex(i, t != 0), null);
                }
            }
            else {
                for (var i = 0; i < (16 - teamCount[t]); i++) {
                    var randIndex = Math.floor(Math.random() * 16);
                    var pos = getCrdFromIndex(randIndex, t != 0);
                    if (getAtCoord(pos) == null)
                        i--;
                    setAtCoord(pos, null);
                    die++;
                    if (die > 256)
                        break;
                }
            }
        }
        outputText += 'I placed the pieces.\n';
        //let dbgText: string = 'startingDebug\n';
        try {
            var userIndex = 0;
            for (var t = 0; t < 2; t++) {
                if (teamCount[t] == 0) {
                    outputText += "There's no one in the " + (t == 0 ? 'black' : 'white') + " team\n";
                    //dbgText += 'skipping team ' + t + ' cuz 0body is in it\n';
                    continue;
                }
                for (var i = 0; i < teamCount[t]; i++) {
                    //dbgText += 'index is '+i+'/'+teamCount[t]+' and team is '+t+'\n';
                    var superPos = getIndexFromTeam(t != 0, i);
                    //dbgText += 'superPos is ' + stringCrd(superPos) + '\n';
                    gamersPositions.push(superPos);
                    var superPiece = getAtCoord(superPos);
                    outputText += currentUsers[userIndex] + ' is a ' + (t == 0 ? 'black ' : 'white ') + pieceName(superPiece.type) + ' at ' + superPos.toPrint() + '\n';
                    userIndex++;
                }
            }
        }
        catch (e) {
            //sendEmbed(msg, 'i crashed but i was debugging, hehe', e.message+'\n'+dbgText); 
        }
        msg.channel.send(outputText + 'Game started with ' + currentUsers.length + ' users. Type `.users` to see who');
    }
    catch (e) {
        sendEmbed(msg, 'Whoops, I crashed', e.message);
    }
    renderPieces(msg, true);
}
function getCrdFromIndex(i, t) {
    return new Coord(Math.floor(i / 8) + (t ? 6 : 0), i % 8);
}
client.on('ready', function () {
    console.log('Logged in as ' + client.user.tag);
    nullifyPieces();
});
client.on('message', function (msg) {
    if (msg.author.bot)
        return;
    command(msg);
    latestMsg = msg;
});
function pieceName(p) {
    switch (p) {
        case "p" /* Pedone */: return 'pawn';
        case "q" /* Regina */: return 'queen';
        case "k" /* Re */: return 'king';
        case "a" /* Alfiere */: return 'bishop';
        case "c" /* Cavallo */: return 'knight';
        case "t" /* Torre */: return 'rook';
    }
}
function sendEmbed(msg, title, text) {
    var emb = new Discord.MessageEmbed()
        .setTitle(title)
        .setColor(0xffffff)
        .setDescription(text);
    msg.channel.send(emb);
    return emb;
}
function getEmbed(title, text) {
    var emb = new Discord.MessageEmbed()
        .setTitle(title)
        .setColor(0xffffff)
        .setDescription(text);
    return emb;
}
function genericHelp(msg, parameters) {
    if (parameters.length == 1) {
        sendEmbed(msg, 'Generic help', '`.` renders the scene\n' +
            '`.join` or `.j` will make you join the game\n' +
            '`.quit` or `.q` will kick you out from the current game players\n' +
            '`.users` or `.u` lists all the users that are currently playing\n' +
            '`.start` or `.s` will create a chess board with as many pieces as current players\n' +
            '`.stop` will clear the board and stop the current game\n' +
            '`.empty` clears the board\n' +
            '`.help ita` explains all the italian terms used\n' +
            '`.help debug` shows debug commands\n' +
            '`.help <first (italian) letter of a piece>` to get info and rules about it\n' +
            '`<param>` means mandatory parameter\n`[param]` means optional parameters');
    }
    else if (parameters.length == 2) {
        switch (parameters[1]) {
            case 'debug':
                sendEmbed(msg, 'Debug help', '`.set <X> <Y> <piece type> <team>` to create a piece on the board\n' +
                    '`.set <X> <Y> empty` to clear a tile on the board\n' +
                    '`.index <piece index> <team>` gets the tile position from index and team of standard chess\n' +
                    '`.index all <team>` lists all the indices of a team\n' +
                    '`.iset <piece index> <team> [<piece type> <team>] | [empty]` like .set but from .index\n' +
                    '`.umove <X of piece pos> <Y of piece pos> <X of future pos> <Y of future pos>` to move piece without rules\n' +
                    '`.move <X of piece pos> <Y of piece pos> <moving message>` to move piece following game rules\n' +
                    '`.reset` sets the board to standard chess\n' +
                    '`.ping` pong!\n' +
                    '`.emoji <emoji name>` sends an emoji from this server from name');
                break;
            case 'ita':
                sendEmbed(msg, 'Italian terms used', "I did'n want to get confused, so i'll confuse you instead.\n" +
                    'pawn (q) = pawn\nknight (c) = knight\nbishop (a) = bishop\nrook (t) = rook\nqueen (q) = queen\nre (k) = king');
                break;
            case 'pawn':
            case 'p':
                sendEmbed(msg, 'pawn movement ' + emoji('wbp'), "The pawn's moving message sintax is `<direction>`\n" +
                    "The direction can be `8` (up) or `2` (down)\n" +
                    "`4` and `6` will both go rigth if the piece is black, left if the piece is white\n" +
                    "The same horizontal direction is applied to `7`, `9`, `1` and `3`");
                break;
            case 'rook':
            case 't':
                sendEmbed(msg, 'rook movement ' + emoji('wbt'), "The rook's moving message sintax is `<direction>[how many times]`\n" +
                    "The direction can be `8`, `2`, `4` and `6`. This move will be played the times that the second parameters says, a number from 0 to 9");
                break;
            case 'queen':
            case 'q':
                sendEmbed(msg, 'queen movement ' + emoji('wbq'), "The queen's moving message sintax is `<direction>[how many times]`\n" +
                    "The direction can be every number from `1` to `9` except `5`. This move will be played the times that the second parameters says, a number from 0 to 9");
                break;
            case 'king':
            case 'k':
                sendEmbed(msg, 'king movement ' + emoji('wbk'), "The king's moving message sintax is `<direction>`\n" +
                    "The direction can be `8`, `2`, `4` and `6`.");
                break;
            case 'bishop':
            case 'a':
                sendEmbed(msg, 'bishop movement ' + emoji('wba'), "The bishop's moving message sintax is `<direction>[how many times]`\n" +
                    "The direction can be `7`, `9`, `1` and `3`. This move will be played the times that the second parameters says, a number from 0 to 9");
                break;
            case 'knight':
            case 'c':
                sendEmbed(msg, 'knight movement ' + emoji('wbc'), "The knight's moving message sintax is `<first direction><second direction>`\n" +
                    "The first direction can be `8`, `2`, `4` and `6`.\n" +
                    "The second one needs to be one of the two diagonal keys next to it\n" +
                    "eg: `23` = L; `87` = ꓶ; `21` = ⅃; `27` = invalid move");
                break;
            case 'me':
                msg.reply('no');
                break;
        }
    }
}
function command(msg) {
    var args = msg.content.split(' ');
    if ((currentUsers.includes(msg.author.tag)) && (args[0].charAt(0) !== '.') && gaming) {
        try {
            var gamerIndex = currentUsers.findIndex(function (item) { return item === msg.author.tag; });
            var startPos = gamersPositions[gamerIndex];
            try {
                var futurePos_1 = startPos.add(getAtCoord(startPos).getCrdFromRule(args[0]));
                if (!startPos.inBoard()) {
                    msg.reply('stay in the board!');
                    return;
                }
                var killed = getAtCoord(futurePos_1);
                if (killed != null) {
                    for (var dedIndex = 0; dedIndex < gamersPositions.length; dedIndex++) {
                        if (gamersPositions[dedIndex].x == futurePos_1.x && gamersPositions[dedIndex].y == futurePos_1.y) {
                            var killedGamerIndex = gamersPositions.findIndex(function (a) { return a.x == futurePos_1.x && a.y == futurePos_1.y; });
                            msg.reply("You killed " + currentUsers[killedGamerIndex]);
                            currentUsers.splice(killedGamerIndex, 1);
                        }
                    }
                }
                setAtCoord(futurePos_1, getAtCoord(startPos));
                setAtCoord(startPos, null);
                gamersPositions[gamerIndex] = futurePos_1;
                renderPieces(msg, false);
                try {
                    msg["delete"]();
                }
                catch (_a) { }
            }
            catch (e) {
                msg.reply(e);
            }
        }
        catch (e) {
            sendEmbed(msg, 'Invalid move! js crash', e.message);
        }
        return;
    }
    switch (args[0]) {
        /// debug
        case '.ping':
            msg.reply('pong!');
            break;
        case '.emoji':
            msg.reply(emoji(args[1]));
            break;
        case '.index':
            var index = parseInt(args[1]);
            var iTeam = !!parseInt(args[2]);
            if (args[1] == 'all') {
                var text_1 = '';
                for (var i = 0; i < 16; i++) {
                    text_1 += i + ' is ' + getCrdFromIndex(i, iTeam).toPrint() + '\n';
                }
                sendEmbed(msg, 'All the indices of ' + (iTeam ? 'white' : 'black') + ' team', text_1);
            }
            else {
                msg.reply('Index ' + index + ' of team ' + (iTeam ? 'white' : 'black') + ' is ' + getCrdFromIndex(index, iTeam).toPrint());
            }
            break;
        case '.help':
            genericHelp(msg, args);
            break;
        case '.echo':
            {
                /*if (msg.author.tag === "MTRC30#9275") {
                    msg.reply("matteo non può usare .echo");
                } else */ latestMsg.channel.send(msg.content.slice(6, msg.content.length));
                try {
                    msg["delete"]();
                }
                catch (_b) { }
            }
            break;
        case '.del':
            try {
                msg["delete"]();
            }
            catch (_c) { }
            /// users playing
            break;
        case '.j':
        case '.join':
            if (!currentUsers.includes(msg.author.tag)) {
                currentUsers.push(msg.author.tag);
                msg.channel.send('<@' + msg.author.id + '> joined the game');
            }
            else
                msg.reply('You already joined');
            break;
        case '.i':
            var userName = msg.content.substring(3);
            if (!currentUsers.includes(userName)) {
                currentUsers.push(userName);
                msg.channel.send(userName + ' joined the game');
            }
            else
                msg.reply(userName + ' already joined');
            break;
        case '.q':
        case '.quit':
            if (currentUsers.includes(msg.author.tag)) {
                currentUsers.splice(currentUsers.findIndex(function (tag) { return tag === msg.author.tag; }), 1);
                msg.channel.send('<@' + msg.author.id + '> left the game');
            }
            else
                msg.reply('You didn\'t join');
            break;
        case '.k':
            var userNameKick_1 = msg.content.substring(3);
            if (currentUsers.includes(userNameKick_1)) {
                currentUsers.splice(currentUsers.findIndex(function (tag) { return tag === userNameKick_1; }), 1);
                msg.channel.send(userNameKick_1 + ' was kicked out by ' + msg.author.tag);
            }
            else
                msg.reply(userNameKick_1 + " didn't join");
            break;
        case '.u':
        case '.users':
            var text = '';
            if (currentUsers.length == 0)
                text = 'No users joined :(';
            else {
                for (var i = 0; i < currentUsers.length; i++) {
                    text += (i + 1).toString() + '. ' + currentUsers[i] + (gaming ? (': ' + gamersPositions[i].toPrint()) : '') + '\n';
                }
            }
            sendEmbed(msg, 'Current users', text);
            break;
        case '.':
            renderPieces(msg, true);
            break;
        case '.empty':
            nullifyPieces();
            break;
        case '.set': /// arg1:startX; arg2:startY; arg3:empty; | [arg3:type; arg4:team]
            var piecePos = new Coord(parseInt(args[1]), parseInt(args[2]));
            if (args[3] === 'empty') {
                setAtCoord(piecePos, null);
                msg.channel.send('Piece at ' + piecePos.toPrint() + ' succesfully emptied');
            }
            else {
                var team = !!parseInt(args[4]);
                setAtCoord(piecePos, ChsPiece.fromChar(args[3], team));
                msg.reply('Piece at ' + piecePos.toPrint() + ' succesfully set to ' + (team ? 'black' : 'white') + pieceName(args[3]));
            }
            break;
        case '.iset':
            var iPiecePos = getCrdFromIndex(parseInt(args[1]), !!parseInt(args[2]));
            if (args[3] === 'empty') {
                setAtCoord(iPiecePos, null);
                msg.channel.send('Piece at ' + iPiecePos.toPrint() + ' succesfully emptied');
            }
            else {
                var team = !!parseInt(args[4]);
                setAtCoord(iPiecePos, ChsPiece.fromChar(args[3], team));
                msg.reply('Piece at ' + iPiecePos.toPrint() + ' succesfully set to ' + (team ? 'black' : 'white') + pieceName(args[3]));
            }
            break;
        case '.reset':
            stdPieces();
            msg.reply('Pieces succesfuly resetted to standard chess');
            break;
        case '.umove':
            var startPos = new Coord(parseInt(args[1]), parseInt(args[2]));
            var targetPos = new Coord(parseInt(args[3]), parseInt(args[4]));
            var startValue = getAtCoord(startPos);
            if (startValue == null) {
                msg.reply("Can't move empty tile");
            }
            else {
                setAtCoord(targetPos, startValue);
                setAtCoord(startPos, null);
                msg.reply((startValue.team ? 'Black' : 'White') + ' ' + pieceName(startValue.type) + ' at ' + startPos.toPrint() + ' succesfully moved to ' + targetPos.toPrint() + ' without following any game rules');
            }
            break;
        case '.version':
            if (args.length < 2)
                msg.reply('current version: v1');
            else {
                if (args[1] == "1")
                    msg.reply('v1: first release');
                else
                    msg.reply('there has never been a ' + args[1] + 'version');
            }
            break;
        case '.info':
            sendEmbed(msg, 'Discord 32Chess', 'Author: catonif#4146\n' +
                'Version: v1 (`.version <version-name>` for more info)\n' +
                'Source code: https://github.com/catonif/discord-chess/ \n' +
                'Type `.help` to learn commands.');
            break;
            break;
        case '.start':
        case '.s':
            gameStart(msg);
            break;
        case '.stop':
            gameStop(msg);
            // one lonely beak ):
            break;
    }
}
client.login(process.env.DISCORDJS_BOT_TOKEN);
